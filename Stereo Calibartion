1. Monochrome calibration

import cv2
import numpy as np
import glob

def findCorners(images_path, pattern_cols, pattern_rows):
    """
    Detects chessboard corners for camera calibration in a set of images.
    
    Parameters
    ----------
    images_path : str
        Path pattern to the calibration images (e.g., 'calib/image_02/data/*.png').
    pattern_cols : int
        Number of interior corners along the horizontal direction (columns).
    pattern_rows : int
        Number of interior corners along the vertical direction (rows).

    Returns
    -------
    objpoints : list of np.ndarray
        List of (N x 3) arrays containing the 3D coordinates of the chessboard
        corners in the board coordinate system. One entry per valid image.
    imgpoints : list of np.ndarray
        List of (N x 1 x 2) arrays containing the 2D detected corner coordinates
        in the image plane. Used together with objpoints for camera calibration
        (cv2.calibrateCamera).
    """
    # Prepare object points
    objp = np.zeros((pattern_cols * pattern_rows, 3), np.float32)
    objp[:, :2] = np.mgrid[0:pattern_cols, 0:pattern_rows].T.reshape(-1, 2)

    objpoints = []   # 3D points in real world
    imgpoints = []   # 2D points in image

    images = sorted(glob.glob(images_path))
    assert images, "Error: No images found."

    for fname in images:
        img = cv2.imread(fname)
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        # Chessboard detection
        ret, corners = cv2.findChessboardCorners(
            gray, (pattern_cols, pattern_rows), None
        )

        if ret:
            objpoints.append(objp)
            imgpoints.append(corners)

            # Draw corners for visualization
            cv2.drawChessboardCorners(img, (pattern_cols, pattern_rows), corners, ret)
            cv2.imshow("Corners", img)
            cv2.waitKey(200)

    cv2.destroyAllWindows()
    cv2.waitKey(100)
    return objpoints, imgpoints


# PROGRAM -- MONOCHROME CALIBRATION OF BOTH CAMARAS --
pattern_cols = 11   # esquinas interiores horizontales
pattern_rows = 7    # esquinas interiores verticales

### --- FOR THE LEFT CAMERA ---
objpoints_L, imgpoints_L = findCorners("calib/image_02/data/*.png",
                                       pattern_cols, pattern_rows)

example_img_L = cv2.imread(glob.glob("calib/image_02/data/*.png")[0])
gray_L = cv2.cvtColor(example_img_L, cv2.COLOR_BGR2GRAY)
img_size_L = gray_L.shape[::-1]   # (width, height)

ret_L, mtx_L, dist_L, rvecs_L, tvecs_L = cv2.calibrateCamera(objpoints_L, imgpoints_L, img_size_L, None, None)

### --- FOR THE RIGHT CAMERA ---

objpoints_R, imgpoints_R = findCorners("calib/image_03/data/*.png",
                                       pattern_cols, pattern_rows)

example_img_R = cv2.imread(glob.glob("calib/image_03/data/*.png")[0])
gray_R = cv2.cvtColor(example_img_R, cv2.COLOR_BGR2GRAY)
img_size_R = gray_R.shape[::-1]   # (width, height)

ret_R, mtx_R, dist_R, rvecs_R, tvecs_R = cv2.calibrateCamera(objpoints_R, imgpoints_R, img_size_R, None, None)


# ------------------------
# STEREO CALIBRATION
# ------------------------

# OpenCV flags: we already know intrinsics from monocular calibration. OPTIONAL
flags = cv2.CALIB_FIX_INTRINSIC

criteria = (cv2.TERM_CRITERIA_MAX_ITER + cv2.TERM_CRITERIA_EPS, 100, 1e-5)

# IMPORTANT:
# objpoints for left and right are THE SAME (same board), so we can use objpoints_L (or objpoints_R)
objpoints_stereo = objpoints_L  

# Run stereo calibration
ret_s, cameraMatrixL, distCoeffL, cameraMatrixR, distCoeffR, R, T, E, F = cv2.stereoCalibrate(
    objpoints_stereo,
    imgpoints_L,
    imgpoints_R,
    mtx_L,
    dist_L,
    mtx_R,
    dist_R,
    img_size_L,
    criteria=criteria,
    flags=flags
)

print("Stereo calibration RMS error:", ret_s)
print("Rotation matrix R:")
print(R)
print("Translation vector T:")
print(T)


